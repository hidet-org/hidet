
// statements
top_level : [(attribute | module)]*

module : "module" [attribute_name] "{" [(function | declare_stmt)]* "}"

function : "def" fn_name "(" fn_args ")" "->" fn_return_type [attribute_name] "{" fn_body "}"

fn_name : IDENT
fn_args : [type_annotation ("," type_annotation)*]
fn_return_type : type
type_annotation : IDENT ":" type

fn_body : [(attribute | stmt)]*

?stmt : declare_stmt
        | buffer_store_stmt
        | assign_stmt
        | return_stmt
        | let_stmt
        | for_stmt
        | while_stmt
        | break_stmt
        | continue_stmt
        | if_stmt
        | assert_stmt
        | black_box_stmt
        | asm_stmt
        | launch_kernel_stmt
        | evaluate_stmt
        // | seq_stmt

declare_stmt : ["static"] "decl" type_annotation ["=" expr] ";" [attribute_name]
buffer_store_stmt : ["protected"] get_item_expr "=" expr ";"
assign_stmt : IDENT "=" expr ";"
return_stmt : "return" expr ";"
let_stmt : "let" "(" (type_annotation "=" expr ";")+ ")" ["in" "(" stmt* ")"] ";"
for_stmt : "for" "(" IDENT ["," IDENT]* ")" "in" call_expr ([attribute_name] | [task_mapping]) "{" stmt* "}"
task_mapping : "on" "(" expr ")"
while_stmt : "while" expr "{" stmt* "}"
break_stmt : "break" ";"
continue_stmt : "continue" ";"
if_stmt : "if" expr "{" stmt* "}" ["else" "{" stmt* "}"]
assert_stmt : "assert" "(" expr ")" ";"
black_box_stmt : "blackbox" "{" ESCAPED_STRING "}" ";"
asm_stmt : ["volatile"] "asm" "{" "{" ESCAPED_STRING "}" "{" [IDENT ("," IDENT)*] "}" "{" [IDENT ("," IDENT)*] "}" "}" ";"
launch_kernel_stmt : IDENT "<<<" dim3 "," dim3 "," [SIGNED_NUMBER] ">>>" "(" [expr ("," expr)*] ")" ";"
dim3 : "(" expr "," expr "," expr ")"
// seq_stmt : "{" stmt* "}"
evaluate_stmt : expr ";"

// mappings
// mapping : spatial_mapping | repeat_mapping | composed_mapping
// spatial_mapping : "@spatial" "(" "shape" "=" int_list "," "ranks" "=" int_list ")"
// repeat_mapping : "@repeat" "(" "shape" "=" int_list "," "ranks" "=" int_list ["," attribute_name]")"
// composed_mapping : "@compose" "(" mapping "," mapping ")"
// int_list : "[" SIGNED_NUMBER ("," SIGNED_NUMBER)* "]"

// expressions
?expr : short_circuit_or_expr

?short_circuit_or_expr : short_circuit_and_expr ("||" short_circuit_and_expr)*
?short_circuit_and_expr : comp_expr ("&&" comp_expr)*
?comp_expr : not_expr (comp_op not_expr)*
?not_expr : "!" or_expr | or_expr
?or_expr: xor_expr ("|" xor_expr)*
?xor_expr: and_expr ("^" and_expr)*
?and_expr: shift_expr ("&" shift_expr)*
?shift_expr: arith_expr (_shift_op arith_expr)*
?arith_expr: term (_add_op term)*
?term: factor (_mul_op factor)*
?factor: _unary_op factor | power
?power: fn_call_expr ("**" factor)?

!_unary_op: "+"|"-"
!_add_op: "+"|"-"
!_shift_op: "<<"|">>"
!_mul_op: "*"|"/"|"%"
!comp_op: "<"|">"|"=="|">="|"<="|"<>"|"!="

?fn_call_expr : get_item_expr 
        | cast_expr 
        | deref_expr 
        | addr_expr 
        | call_expr 
        | let_expr 
        | if_then_else_expr 
        | atom

// tensor_slice_expr : expr "[" [slice ("," slice)*] "]"
get_item_expr : expr "[" [(expr | slice) ("," (expr | slice))*] "]"
slice : [expr] ":" [expr]
call_expr : expr "(" [expr ("," expr)*] [("," keyword_arg)*] ")"
keyword_arg : IDENT "=" expr
cast_expr : "cast" "<" type ">" "(" expr ")"
deref_expr : "deref" "(" expr ")"
addr_expr : "addr" "(" expr ")"

let_expr : "let" "(" type_annotation "=" expr ")" "in" "(" expr ")"
if_then_else_expr : "if" expr "then" "{" expr "}" "else" "{" expr "}"

?atom : "(" expr ")"
        | get_attr
        | "true" -> true
        | "false" -> false
        | "none" -> none
        | symbol_var
        | IDENT -> var
        | ESCAPED_STRING
        | INT
        | SIGNED_NUMBER

get_attr : expr "." IDENT

// Types
?type : data_type | tensor_type | ptr_type

ptr_type : "~" type
tensor_type : data_type "<" [tensor_tt_shape ("," tensor_tt_shape)*] [tensor_layout] ">"
?tensor_tt_shape : INT | symbol_var
tensor_layout : ";" expr
!data_type : "i8" | "i16" | "i32" | "i64" | "u8" | "u16" | "u32" | "u64" | "f16" | "f32" | "f64" | "bool" | "void"

// attributes
attribute_name : "#" IDENT
attribute : attribute_name "=" dict ";"

// python objects (or constants)
?value: dict
        | list
        // | tuple
        | ESCAPED_STRING
        | INT
        | SIGNED_NUMBER
        | "true"             -> true
        | "false"            -> false
        | "none"             -> none
        | expr

pair : ESCAPED_STRING ":" value
dict : "{" [pair ("," pair)*] "}"
list : "[" [value ("," value)*] "]"
// tuple : "(" value "," (value ",")* ")"

symbol_var : "@" IDENT

IDENT : /[^\W\d]\w*/
%import common.ESCAPED_STRING
%import common.SIGNED_NUMBER
%import common.INT
%import common.WS
%ignore WS